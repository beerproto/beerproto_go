//*
// BeerProto
//
// Another beer format, written in protocol buffer.
//
// Copyright (c) 2020 Ross Merrigan

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: beerproto/v1/culture.proto

package beerprotov1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type QualitativeRangeUnit int32

const (
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_UNSPECIFIED QualitativeRangeUnit = 0
	// very low
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_VERY_LOW QualitativeRangeUnit = 1
	// low
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_LOW QualitativeRangeUnit = 2
	// medium low
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_MEDIUM_LOW QualitativeRangeUnit = 3
	// medium
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_MEDIUM QualitativeRangeUnit = 4
	// medium high
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_MEDIUM_HIGH QualitativeRangeUnit = 5
	// high
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_HIGH QualitativeRangeUnit = 6
	// very high
	QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_VERY_HIGH QualitativeRangeUnit = 7
)

// Enum value maps for QualitativeRangeUnit.
var (
	QualitativeRangeUnit_name = map[int32]string{
		0: "QUALITATIVE_RANGE_UNIT_UNSPECIFIED",
		1: "QUALITATIVE_RANGE_UNIT_VERY_LOW",
		2: "QUALITATIVE_RANGE_UNIT_LOW",
		3: "QUALITATIVE_RANGE_UNIT_MEDIUM_LOW",
		4: "QUALITATIVE_RANGE_UNIT_MEDIUM",
		5: "QUALITATIVE_RANGE_UNIT_MEDIUM_HIGH",
		6: "QUALITATIVE_RANGE_UNIT_HIGH",
		7: "QUALITATIVE_RANGE_UNIT_VERY_HIGH",
	}
	QualitativeRangeUnit_value = map[string]int32{
		"QUALITATIVE_RANGE_UNIT_UNSPECIFIED": 0,
		"QUALITATIVE_RANGE_UNIT_VERY_LOW":    1,
		"QUALITATIVE_RANGE_UNIT_LOW":         2,
		"QUALITATIVE_RANGE_UNIT_MEDIUM_LOW":  3,
		"QUALITATIVE_RANGE_UNIT_MEDIUM":      4,
		"QUALITATIVE_RANGE_UNIT_MEDIUM_HIGH": 5,
		"QUALITATIVE_RANGE_UNIT_HIGH":        6,
		"QUALITATIVE_RANGE_UNIT_VERY_HIGH":   7,
	}
)

func (x QualitativeRangeUnit) Enum() *QualitativeRangeUnit {
	p := new(QualitativeRangeUnit)
	*p = x
	return p
}

func (x QualitativeRangeUnit) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (QualitativeRangeUnit) Descriptor() protoreflect.EnumDescriptor {
	return file_beerproto_v1_culture_proto_enumTypes[0].Descriptor()
}

func (QualitativeRangeUnit) Type() protoreflect.EnumType {
	return &file_beerproto_v1_culture_proto_enumTypes[0]
}

func (x QualitativeRangeUnit) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use QualitativeRangeUnit.Descriptor instead.
func (QualitativeRangeUnit) EnumDescriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{0}
}

type CultureBaseForm int32

const (
	CultureBaseForm_CULTURE_BASE_FORM_UNSPECIFIED CultureBaseForm = 0
	// liquid
	CultureBaseForm_CULTURE_BASE_FORM_LIQUID CultureBaseForm = 1
	// dry
	CultureBaseForm_CULTURE_BASE_FORM_DRY CultureBaseForm = 2
	// slant
	CultureBaseForm_CULTURE_BASE_FORM_SLANT CultureBaseForm = 3
	// culture
	CultureBaseForm_CULTURE_BASE_FORM_CULTURE CultureBaseForm = 4
	// dregs
	CultureBaseForm_CULTURE_BASE_FORM_DREGS CultureBaseForm = 5
)

// Enum value maps for CultureBaseForm.
var (
	CultureBaseForm_name = map[int32]string{
		0: "CULTURE_BASE_FORM_UNSPECIFIED",
		1: "CULTURE_BASE_FORM_LIQUID",
		2: "CULTURE_BASE_FORM_DRY",
		3: "CULTURE_BASE_FORM_SLANT",
		4: "CULTURE_BASE_FORM_CULTURE",
		5: "CULTURE_BASE_FORM_DREGS",
	}
	CultureBaseForm_value = map[string]int32{
		"CULTURE_BASE_FORM_UNSPECIFIED": 0,
		"CULTURE_BASE_FORM_LIQUID":      1,
		"CULTURE_BASE_FORM_DRY":         2,
		"CULTURE_BASE_FORM_SLANT":       3,
		"CULTURE_BASE_FORM_CULTURE":     4,
		"CULTURE_BASE_FORM_DREGS":       5,
	}
)

func (x CultureBaseForm) Enum() *CultureBaseForm {
	p := new(CultureBaseForm)
	*p = x
	return p
}

func (x CultureBaseForm) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CultureBaseForm) Descriptor() protoreflect.EnumDescriptor {
	return file_beerproto_v1_culture_proto_enumTypes[1].Descriptor()
}

func (CultureBaseForm) Type() protoreflect.EnumType {
	return &file_beerproto_v1_culture_proto_enumTypes[1]
}

func (x CultureBaseForm) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CultureBaseForm.Descriptor instead.
func (CultureBaseForm) EnumDescriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{1}
}

type CultureBaseType int32

const (
	CultureBaseType_CULTURE_BASE_TYPE_UNSPECIFIED CultureBaseType = 0
	// ale
	CultureBaseType_CULTURE_BASE_TYPE_ALE CultureBaseType = 1
	// bacteria
	CultureBaseType_CULTURE_BASE_TYPE_BACTERIA CultureBaseType = 2
	// brett
	CultureBaseType_CULTURE_BASE_TYPE_BRETT CultureBaseType = 3
	// champagne
	CultureBaseType_CULTURE_BASE_TYPE_CHAMPAGNE CultureBaseType = 4
	// kveik
	CultureBaseType_CULTURE_BASE_TYPE_KVEIK CultureBaseType = 5
	// lacto
	CultureBaseType_CULTURE_BASE_TYPE_LACTO CultureBaseType = 6
	// lager
	CultureBaseType_CULTURE_BASE_TYPE_LAGER CultureBaseType = 7
	// malolactic
	CultureBaseType_CULTURE_BASE_TYPE_MALOLACTIC CultureBaseType = 8
	// mixed-culture
	CultureBaseType_CULTURE_BASE_TYPE_MIXED_CULTURE CultureBaseType = 9
	// other
	CultureBaseType_CULTURE_BASE_TYPE_OTHER CultureBaseType = 10
	// pedio
	CultureBaseType_CULTURE_BASE_TYPE_PEDIO CultureBaseType = 11
	// spontaneous
	CultureBaseType_CULTURE_BASE_TYPE_SPONTANEOUS CultureBaseType = 12
	// wine
	CultureBaseType_CULTURE_BASE_TYPE_WINE CultureBaseType = 13
)

// Enum value maps for CultureBaseType.
var (
	CultureBaseType_name = map[int32]string{
		0:  "CULTURE_BASE_TYPE_UNSPECIFIED",
		1:  "CULTURE_BASE_TYPE_ALE",
		2:  "CULTURE_BASE_TYPE_BACTERIA",
		3:  "CULTURE_BASE_TYPE_BRETT",
		4:  "CULTURE_BASE_TYPE_CHAMPAGNE",
		5:  "CULTURE_BASE_TYPE_KVEIK",
		6:  "CULTURE_BASE_TYPE_LACTO",
		7:  "CULTURE_BASE_TYPE_LAGER",
		8:  "CULTURE_BASE_TYPE_MALOLACTIC",
		9:  "CULTURE_BASE_TYPE_MIXED_CULTURE",
		10: "CULTURE_BASE_TYPE_OTHER",
		11: "CULTURE_BASE_TYPE_PEDIO",
		12: "CULTURE_BASE_TYPE_SPONTANEOUS",
		13: "CULTURE_BASE_TYPE_WINE",
	}
	CultureBaseType_value = map[string]int32{
		"CULTURE_BASE_TYPE_UNSPECIFIED":   0,
		"CULTURE_BASE_TYPE_ALE":           1,
		"CULTURE_BASE_TYPE_BACTERIA":      2,
		"CULTURE_BASE_TYPE_BRETT":         3,
		"CULTURE_BASE_TYPE_CHAMPAGNE":     4,
		"CULTURE_BASE_TYPE_KVEIK":         5,
		"CULTURE_BASE_TYPE_LACTO":         6,
		"CULTURE_BASE_TYPE_LAGER":         7,
		"CULTURE_BASE_TYPE_MALOLACTIC":    8,
		"CULTURE_BASE_TYPE_MIXED_CULTURE": 9,
		"CULTURE_BASE_TYPE_OTHER":         10,
		"CULTURE_BASE_TYPE_PEDIO":         11,
		"CULTURE_BASE_TYPE_SPONTANEOUS":   12,
		"CULTURE_BASE_TYPE_WINE":          13,
	}
)

func (x CultureBaseType) Enum() *CultureBaseType {
	p := new(CultureBaseType)
	*p = x
	return p
}

func (x CultureBaseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CultureBaseType) Descriptor() protoreflect.EnumDescriptor {
	return file_beerproto_v1_culture_proto_enumTypes[2].Descriptor()
}

func (CultureBaseType) Type() protoreflect.EnumType {
	return &file_beerproto_v1_culture_proto_enumTypes[2]
}

func (x CultureBaseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CultureBaseType.Descriptor instead.
func (CultureBaseType) EnumDescriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{2}
}

// CultureBase Provides unique properties to identify individual records of a culture.
type CultureBase struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type          CultureBaseType        `protobuf:"varint,2,opt,name=type,proto3,enum=beerproto.v1.CultureBaseType" json:"type,omitempty"`
	Form          CultureBaseForm        `protobuf:"varint,3,opt,name=form,proto3,enum=beerproto.v1.CultureBaseForm" json:"form,omitempty"`
	Producer      string                 `protobuf:"bytes,4,opt,name=producer,proto3" json:"producer,omitempty"`
	ProductId     string                 `protobuf:"bytes,5,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CultureBase) Reset() {
	*x = CultureBase{}
	mi := &file_beerproto_v1_culture_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CultureBase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CultureBase) ProtoMessage() {}

func (x *CultureBase) ProtoReflect() protoreflect.Message {
	mi := &file_beerproto_v1_culture_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CultureBase.ProtoReflect.Descriptor instead.
func (*CultureBase) Descriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{0}
}

func (x *CultureBase) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CultureBase) GetType() CultureBaseType {
	if x != nil {
		return x.Type
	}
	return CultureBaseType_CULTURE_BASE_TYPE_UNSPECIFIED
}

func (x *CultureBase) GetForm() CultureBaseForm {
	if x != nil {
		return x.Form
	}
	return CultureBaseForm_CULTURE_BASE_FORM_UNSPECIFIED
}

func (x *CultureBase) GetProducer() string {
	if x != nil {
		return x.Producer
	}
	return ""
}

func (x *CultureBase) GetProductId() string {
	if x != nil {
		return x.ProductId
	}
	return ""
}

// CultureInformation collects the attributes of a microbial culture
type CultureInformation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Base  *CultureBase           `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id    string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// The recommended temperature range of fermentation by the culture producer.
	TemperatureRange *TemperatureRangeType `protobuf:"bytes,3,opt,name=temperature_range,json=temperatureRange,proto3" json:"temperature_range,omitempty"`
	Notes            string                `protobuf:"bytes,4,opt,name=notes,proto3" json:"notes,omitempty"`
	// Recommended styles for a particular culture.
	BestFor   string                `protobuf:"bytes,5,opt,name=best_for,json=bestFor,proto3" json:"best_for,omitempty"`
	Inventory *CultureInventoryType `protobuf:"bytes,6,opt,name=inventory,proto3" json:"inventory,omitempty"`
	Name      string                `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// The recommended limit of abv by the culture producer before attenuation stops.
	AlcoholTolerance *PercentType `protobuf:"bytes,8,opt,name=alcohol_tolerance,json=alcoholTolerance,proto3" json:"alcohol_tolerance,omitempty"`
	// A glucoamylase positive culture is capable of producing glucoamylase, the enzyme produced through expression of the diastatic gene, which allows yeast to attenuate dextrins and starches leading to a very low FG. This is positive in some saison/brett yeasts as well as the new gulo hybrid by Omega yeast labs.
	Glucoamylase bool            `protobuf:"varint,9,opt,name=glucoamylase,proto3" json:"glucoamylase,omitempty"`
	Type         CultureBaseType `protobuf:"varint,10,opt,name=type,proto3,enum=beerproto.v1.CultureBaseType" json:"type,omitempty"`
	// Floculation refers to the ability of yeast to aggregate to form large flocs which drop out of suspension.
	Flocculation     QualitativeRangeUnit `protobuf:"varint,11,opt,name=flocculation,proto3,enum=beerproto.v1.QualitativeRangeUnit" json:"flocculation,omitempty"`
	AttenuationRange *PercentRangeType    `protobuf:"bytes,12,opt,name=attenuation_range,json=attenuationRange,proto3" json:"attenuation_range,omitempty"`
	// Maximum number of times to reuse a culture before a new lab source is recommended.
	MaxReuse int32 `protobuf:"varint,13,opt,name=max_reuse,json=maxReuse,proto3" json:"max_reuse,omitempty"`
	// A POF+ culture is capable of producing phenols, which is a common distinctive property of saison, and brett yeasts.
	Pof           bool      `protobuf:"varint,14,opt,name=pof,proto3" json:"pof,omitempty"`
	Zymocide      *Zymocide `protobuf:"bytes,15,opt,name=zymocide,proto3" json:"zymocide,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CultureInformation) Reset() {
	*x = CultureInformation{}
	mi := &file_beerproto_v1_culture_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CultureInformation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CultureInformation) ProtoMessage() {}

func (x *CultureInformation) ProtoReflect() protoreflect.Message {
	mi := &file_beerproto_v1_culture_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CultureInformation.ProtoReflect.Descriptor instead.
func (*CultureInformation) Descriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{1}
}

func (x *CultureInformation) GetBase() *CultureBase {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *CultureInformation) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CultureInformation) GetTemperatureRange() *TemperatureRangeType {
	if x != nil {
		return x.TemperatureRange
	}
	return nil
}

func (x *CultureInformation) GetNotes() string {
	if x != nil {
		return x.Notes
	}
	return ""
}

func (x *CultureInformation) GetBestFor() string {
	if x != nil {
		return x.BestFor
	}
	return ""
}

func (x *CultureInformation) GetInventory() *CultureInventoryType {
	if x != nil {
		return x.Inventory
	}
	return nil
}

func (x *CultureInformation) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CultureInformation) GetAlcoholTolerance() *PercentType {
	if x != nil {
		return x.AlcoholTolerance
	}
	return nil
}

func (x *CultureInformation) GetGlucoamylase() bool {
	if x != nil {
		return x.Glucoamylase
	}
	return false
}

func (x *CultureInformation) GetType() CultureBaseType {
	if x != nil {
		return x.Type
	}
	return CultureBaseType_CULTURE_BASE_TYPE_UNSPECIFIED
}

func (x *CultureInformation) GetFlocculation() QualitativeRangeUnit {
	if x != nil {
		return x.Flocculation
	}
	return QualitativeRangeUnit_QUALITATIVE_RANGE_UNIT_UNSPECIFIED
}

func (x *CultureInformation) GetAttenuationRange() *PercentRangeType {
	if x != nil {
		return x.AttenuationRange
	}
	return nil
}

func (x *CultureInformation) GetMaxReuse() int32 {
	if x != nil {
		return x.MaxReuse
	}
	return 0
}

func (x *CultureInformation) GetPof() bool {
	if x != nil {
		return x.Pof
	}
	return false
}

func (x *CultureInformation) GetZymocide() *Zymocide {
	if x != nil {
		return x.Zymocide
	}
	return nil
}

// CultureAdditionType collects the attributes of each culture ingredient for use in a recipe
type CultureAdditionType struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Base              *CultureBase           `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Id                string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	CellCountBillions int32                  `protobuf:"varint,3,opt,name=cell_count_billions,json=cellCountBillions,proto3" json:"cell_count_billions,omitempty"`
	TimesCultured     int32                  `protobuf:"varint,4,opt,name=times_cultured,json=timesCultured,proto3" json:"times_cultured,omitempty"`
	Type              CultureBaseType        `protobuf:"varint,5,opt,name=type,proto3,enum=beerproto.v1.CultureBaseType" json:"type,omitempty"`
	// The expected, or measured apparent attenuation for a given culture in a given recipe. In comparison to attenuation range, this is a single value.
	Attenuation *PercentType `protobuf:"bytes,6,opt,name=attenuation,proto3" json:"attenuation,omitempty"`
	// The timing object fully describes the timing of an addition with options for basis on time, gravity, or pH at any process step.
	Timing *TimingType `protobuf:"bytes,7,opt,name=timing,proto3" json:"timing,omitempty"`
	// Types that are valid to be assigned to Amount:
	//
	//	*CultureAdditionType_Mass
	//	*CultureAdditionType_Unit
	//	*CultureAdditionType_Volume
	Amount        isCultureAdditionType_Amount `protobuf_oneof:"amount"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CultureAdditionType) Reset() {
	*x = CultureAdditionType{}
	mi := &file_beerproto_v1_culture_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CultureAdditionType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CultureAdditionType) ProtoMessage() {}

func (x *CultureAdditionType) ProtoReflect() protoreflect.Message {
	mi := &file_beerproto_v1_culture_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CultureAdditionType.ProtoReflect.Descriptor instead.
func (*CultureAdditionType) Descriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{2}
}

func (x *CultureAdditionType) GetBase() *CultureBase {
	if x != nil {
		return x.Base
	}
	return nil
}

func (x *CultureAdditionType) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CultureAdditionType) GetCellCountBillions() int32 {
	if x != nil {
		return x.CellCountBillions
	}
	return 0
}

func (x *CultureAdditionType) GetTimesCultured() int32 {
	if x != nil {
		return x.TimesCultured
	}
	return 0
}

func (x *CultureAdditionType) GetType() CultureBaseType {
	if x != nil {
		return x.Type
	}
	return CultureBaseType_CULTURE_BASE_TYPE_UNSPECIFIED
}

func (x *CultureAdditionType) GetAttenuation() *PercentType {
	if x != nil {
		return x.Attenuation
	}
	return nil
}

func (x *CultureAdditionType) GetTiming() *TimingType {
	if x != nil {
		return x.Timing
	}
	return nil
}

func (x *CultureAdditionType) GetAmount() isCultureAdditionType_Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *CultureAdditionType) GetMass() *MassType {
	if x != nil {
		if x, ok := x.Amount.(*CultureAdditionType_Mass); ok {
			return x.Mass
		}
	}
	return nil
}

func (x *CultureAdditionType) GetUnit() *UnitType {
	if x != nil {
		if x, ok := x.Amount.(*CultureAdditionType_Unit); ok {
			return x.Unit
		}
	}
	return nil
}

func (x *CultureAdditionType) GetVolume() *VolumeType {
	if x != nil {
		if x, ok := x.Amount.(*CultureAdditionType_Volume); ok {
			return x.Volume
		}
	}
	return nil
}

type isCultureAdditionType_Amount interface {
	isCultureAdditionType_Amount()
}

type CultureAdditionType_Mass struct {
	Mass *MassType `protobuf:"bytes,8,opt,name=mass,proto3,oneof"`
}

type CultureAdditionType_Unit struct {
	Unit *UnitType `protobuf:"bytes,9,opt,name=unit,proto3,oneof"`
}

type CultureAdditionType_Volume struct {
	Volume *VolumeType `protobuf:"bytes,10,opt,name=volume,proto3,oneof"`
}

func (*CultureAdditionType_Mass) isCultureAdditionType_Amount() {}

func (*CultureAdditionType_Unit) isCultureAdditionType_Amount() {}

func (*CultureAdditionType_Volume) isCultureAdditionType_Amount() {}

type CultureInventoryType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Liquid        *VolumeType            `protobuf:"bytes,1,opt,name=liquid,proto3" json:"liquid,omitempty"`
	Dry           *MassType              `protobuf:"bytes,2,opt,name=dry,proto3" json:"dry,omitempty"`
	Slant         *VolumeType            `protobuf:"bytes,3,opt,name=slant,proto3" json:"slant,omitempty"`
	Culture       *VolumeType            `protobuf:"bytes,4,opt,name=culture,proto3" json:"culture,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CultureInventoryType) Reset() {
	*x = CultureInventoryType{}
	mi := &file_beerproto_v1_culture_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CultureInventoryType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CultureInventoryType) ProtoMessage() {}

func (x *CultureInventoryType) ProtoReflect() protoreflect.Message {
	mi := &file_beerproto_v1_culture_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CultureInventoryType.ProtoReflect.Descriptor instead.
func (*CultureInventoryType) Descriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{3}
}

func (x *CultureInventoryType) GetLiquid() *VolumeType {
	if x != nil {
		return x.Liquid
	}
	return nil
}

func (x *CultureInventoryType) GetDry() *MassType {
	if x != nil {
		return x.Dry
	}
	return nil
}

func (x *CultureInventoryType) GetSlant() *VolumeType {
	if x != nil {
		return x.Slant
	}
	return nil
}

func (x *CultureInventoryType) GetCulture() *VolumeType {
	if x != nil {
		return x.Culture
	}
	return nil
}

// Zymocide, also known as killer yeast properties, is common among wine yeast. There are also some ale and brett yeasts that are immune to some zymocidic properties, these are known as killer neutral
type Zymocide struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	No1           bool                   `protobuf:"varint,1,opt,name=no1,proto3" json:"no1,omitempty"`
	No2           bool                   `protobuf:"varint,2,opt,name=no2,proto3" json:"no2,omitempty"`
	No28          bool                   `protobuf:"varint,3,opt,name=no28,proto3" json:"no28,omitempty"`
	Klus          bool                   `protobuf:"varint,4,opt,name=klus,proto3" json:"klus,omitempty"`
	Neutral       bool                   `protobuf:"varint,5,opt,name=neutral,proto3" json:"neutral,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Zymocide) Reset() {
	*x = Zymocide{}
	mi := &file_beerproto_v1_culture_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Zymocide) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Zymocide) ProtoMessage() {}

func (x *Zymocide) ProtoReflect() protoreflect.Message {
	mi := &file_beerproto_v1_culture_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Zymocide.ProtoReflect.Descriptor instead.
func (*Zymocide) Descriptor() ([]byte, []int) {
	return file_beerproto_v1_culture_proto_rawDescGZIP(), []int{4}
}

func (x *Zymocide) GetNo1() bool {
	if x != nil {
		return x.No1
	}
	return false
}

func (x *Zymocide) GetNo2() bool {
	if x != nil {
		return x.No2
	}
	return false
}

func (x *Zymocide) GetNo28() bool {
	if x != nil {
		return x.No28
	}
	return false
}

func (x *Zymocide) GetKlus() bool {
	if x != nil {
		return x.Klus
	}
	return false
}

func (x *Zymocide) GetNeutral() bool {
	if x != nil {
		return x.Neutral
	}
	return false
}

var File_beerproto_v1_culture_proto protoreflect.FileDescriptor

const file_beerproto_v1_culture_proto_rawDesc = "" +
	"\n" +
	"\x1abeerproto/v1/culture.proto\x12\fbeerproto.v1\x1a$beerproto/v1/measureable_units.proto\x1a\x19beerproto/v1/timing.proto\x1a\x1bbuf/validate/validate.proto\"\xe8\x01\n" +
	"\vCultureBase\x12\x1e\n" +
	"\x04name\x18\x01 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x10\x03R\x04name\x12>\n" +
	"\x04type\x18\x02 \x01(\x0e2\x1d.beerproto.v1.CultureBaseTypeB\v\xbaH\b\xc8\x01\x01\x82\x01\x02 \x00R\x04type\x12>\n" +
	"\x04form\x18\x03 \x01(\x0e2\x1d.beerproto.v1.CultureBaseFormB\v\xbaH\b\xc8\x01\x01\x82\x01\x02 \x00R\x04form\x12\x1a\n" +
	"\bproducer\x18\x04 \x01(\tR\bproducer\x12\x1d\n" +
	"\n" +
	"product_id\x18\x05 \x01(\tR\tproductId\"\xd7\x05\n" +
	"\x12CultureInformation\x125\n" +
	"\x04base\x18\x01 \x01(\v2\x19.beerproto.v1.CultureBaseB\x06\xbaH\x03\xc8\x01\x01R\x04base\x12\x1b\n" +
	"\x02id\x18\x02 \x01(\tB\v\xbaH\b\xc8\x01\x01r\x03\xb0\x01\x01R\x02id\x12O\n" +
	"\x11temperature_range\x18\x03 \x01(\v2\".beerproto.v1.TemperatureRangeTypeR\x10temperatureRange\x12\x14\n" +
	"\x05notes\x18\x04 \x01(\tR\x05notes\x12\x19\n" +
	"\bbest_for\x18\x05 \x01(\tR\abestFor\x12@\n" +
	"\tinventory\x18\x06 \x01(\v2\".beerproto.v1.CultureInventoryTypeR\tinventory\x12\x12\n" +
	"\x04name\x18\a \x01(\tR\x04name\x12F\n" +
	"\x11alcohol_tolerance\x18\b \x01(\v2\x19.beerproto.v1.PercentTypeR\x10alcoholTolerance\x12\"\n" +
	"\fglucoamylase\x18\t \x01(\bR\fglucoamylase\x121\n" +
	"\x04type\x18\n" +
	" \x01(\x0e2\x1d.beerproto.v1.CultureBaseTypeR\x04type\x12F\n" +
	"\fflocculation\x18\v \x01(\x0e2\".beerproto.v1.QualitativeRangeUnitR\fflocculation\x12K\n" +
	"\x11attenuation_range\x18\f \x01(\v2\x1e.beerproto.v1.PercentRangeTypeR\x10attenuationRange\x12\x1b\n" +
	"\tmax_reuse\x18\r \x01(\x05R\bmaxReuse\x12\x10\n" +
	"\x03pof\x18\x0e \x01(\bR\x03pof\x122\n" +
	"\bzymocide\x18\x0f \x01(\v2\x16.beerproto.v1.ZymocideR\bzymocide\"\x83\x04\n" +
	"\x13CultureAdditionType\x125\n" +
	"\x04base\x18\x01 \x01(\v2\x19.beerproto.v1.CultureBaseB\x06\xbaH\x03\xc8\x01\x01R\x04base\x12\x1b\n" +
	"\x02id\x18\x02 \x01(\tB\v\xbaH\b\xc8\x01\x01r\x03\xb0\x01\x01R\x02id\x12.\n" +
	"\x13cell_count_billions\x18\x03 \x01(\x05R\x11cellCountBillions\x12%\n" +
	"\x0etimes_cultured\x18\x04 \x01(\x05R\rtimesCultured\x121\n" +
	"\x04type\x18\x05 \x01(\x0e2\x1d.beerproto.v1.CultureBaseTypeR\x04type\x12;\n" +
	"\vattenuation\x18\x06 \x01(\v2\x19.beerproto.v1.PercentTypeR\vattenuation\x120\n" +
	"\x06timing\x18\a \x01(\v2\x18.beerproto.v1.TimingTypeR\x06timing\x12,\n" +
	"\x04mass\x18\b \x01(\v2\x16.beerproto.v1.MassTypeH\x00R\x04mass\x12,\n" +
	"\x04unit\x18\t \x01(\v2\x16.beerproto.v1.UnitTypeH\x00R\x04unit\x122\n" +
	"\x06volume\x18\n" +
	" \x01(\v2\x18.beerproto.v1.VolumeTypeH\x00R\x06volumeB\x0f\n" +
	"\x06amount\x12\x05\xbaH\x02\b\x01\"\xd6\x01\n" +
	"\x14CultureInventoryType\x120\n" +
	"\x06liquid\x18\x01 \x01(\v2\x18.beerproto.v1.VolumeTypeR\x06liquid\x12(\n" +
	"\x03dry\x18\x02 \x01(\v2\x16.beerproto.v1.MassTypeR\x03dry\x12.\n" +
	"\x05slant\x18\x03 \x01(\v2\x18.beerproto.v1.VolumeTypeR\x05slant\x122\n" +
	"\aculture\x18\x04 \x01(\v2\x18.beerproto.v1.VolumeTypeR\aculture\"p\n" +
	"\bZymocide\x12\x10\n" +
	"\x03no1\x18\x01 \x01(\bR\x03no1\x12\x10\n" +
	"\x03no2\x18\x02 \x01(\bR\x03no2\x12\x12\n" +
	"\x04no28\x18\x03 \x01(\bR\x04no28\x12\x12\n" +
	"\x04klus\x18\x04 \x01(\bR\x04klus\x12\x18\n" +
	"\aneutral\x18\x05 \x01(\bR\aneutral*\xbc\x02\n" +
	"\x14QualitativeRangeUnit\x12&\n" +
	"\"QUALITATIVE_RANGE_UNIT_UNSPECIFIED\x10\x00\x12#\n" +
	"\x1fQUALITATIVE_RANGE_UNIT_VERY_LOW\x10\x01\x12\x1e\n" +
	"\x1aQUALITATIVE_RANGE_UNIT_LOW\x10\x02\x12%\n" +
	"!QUALITATIVE_RANGE_UNIT_MEDIUM_LOW\x10\x03\x12!\n" +
	"\x1dQUALITATIVE_RANGE_UNIT_MEDIUM\x10\x04\x12&\n" +
	"\"QUALITATIVE_RANGE_UNIT_MEDIUM_HIGH\x10\x05\x12\x1f\n" +
	"\x1bQUALITATIVE_RANGE_UNIT_HIGH\x10\x06\x12$\n" +
	" QUALITATIVE_RANGE_UNIT_VERY_HIGH\x10\a*\xc6\x01\n" +
	"\x0fCultureBaseForm\x12!\n" +
	"\x1dCULTURE_BASE_FORM_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18CULTURE_BASE_FORM_LIQUID\x10\x01\x12\x19\n" +
	"\x15CULTURE_BASE_FORM_DRY\x10\x02\x12\x1b\n" +
	"\x17CULTURE_BASE_FORM_SLANT\x10\x03\x12\x1d\n" +
	"\x19CULTURE_BASE_FORM_CULTURE\x10\x04\x12\x1b\n" +
	"\x17CULTURE_BASE_FORM_DREGS\x10\x05*\xc4\x03\n" +
	"\x0fCultureBaseType\x12!\n" +
	"\x1dCULTURE_BASE_TYPE_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15CULTURE_BASE_TYPE_ALE\x10\x01\x12\x1e\n" +
	"\x1aCULTURE_BASE_TYPE_BACTERIA\x10\x02\x12\x1b\n" +
	"\x17CULTURE_BASE_TYPE_BRETT\x10\x03\x12\x1f\n" +
	"\x1bCULTURE_BASE_TYPE_CHAMPAGNE\x10\x04\x12\x1b\n" +
	"\x17CULTURE_BASE_TYPE_KVEIK\x10\x05\x12\x1b\n" +
	"\x17CULTURE_BASE_TYPE_LACTO\x10\x06\x12\x1b\n" +
	"\x17CULTURE_BASE_TYPE_LAGER\x10\a\x12 \n" +
	"\x1cCULTURE_BASE_TYPE_MALOLACTIC\x10\b\x12#\n" +
	"\x1fCULTURE_BASE_TYPE_MIXED_CULTURE\x10\t\x12\x1b\n" +
	"\x17CULTURE_BASE_TYPE_OTHER\x10\n" +
	"\x12\x1b\n" +
	"\x17CULTURE_BASE_TYPE_PEDIO\x10\v\x12!\n" +
	"\x1dCULTURE_BASE_TYPE_SPONTANEOUS\x10\f\x12\x1a\n" +
	"\x16CULTURE_BASE_TYPE_WINE\x10\rB\xad\x01\n" +
	"\x10com.beerproto.v1B\fCultureProtoP\x01Z:github.com/beerproto/beerproto_go/beerproto/v1;beerprotov1\xa2\x02\x03BXX\xaa\x02\fBeerproto.V1\xca\x02\fBeerproto\\V1\xe2\x02\x18Beerproto\\V1\\GPBMetadata\xea\x02\rBeerproto::V1b\x06proto3"

var (
	file_beerproto_v1_culture_proto_rawDescOnce sync.Once
	file_beerproto_v1_culture_proto_rawDescData []byte
)

func file_beerproto_v1_culture_proto_rawDescGZIP() []byte {
	file_beerproto_v1_culture_proto_rawDescOnce.Do(func() {
		file_beerproto_v1_culture_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_beerproto_v1_culture_proto_rawDesc), len(file_beerproto_v1_culture_proto_rawDesc)))
	})
	return file_beerproto_v1_culture_proto_rawDescData
}

var file_beerproto_v1_culture_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_beerproto_v1_culture_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_beerproto_v1_culture_proto_goTypes = []any{
	(QualitativeRangeUnit)(0),    // 0: beerproto.v1.QualitativeRangeUnit
	(CultureBaseForm)(0),         // 1: beerproto.v1.CultureBaseForm
	(CultureBaseType)(0),         // 2: beerproto.v1.CultureBaseType
	(*CultureBase)(nil),          // 3: beerproto.v1.CultureBase
	(*CultureInformation)(nil),   // 4: beerproto.v1.CultureInformation
	(*CultureAdditionType)(nil),  // 5: beerproto.v1.CultureAdditionType
	(*CultureInventoryType)(nil), // 6: beerproto.v1.CultureInventoryType
	(*Zymocide)(nil),             // 7: beerproto.v1.Zymocide
	(*TemperatureRangeType)(nil), // 8: beerproto.v1.TemperatureRangeType
	(*PercentType)(nil),          // 9: beerproto.v1.PercentType
	(*PercentRangeType)(nil),     // 10: beerproto.v1.PercentRangeType
	(*TimingType)(nil),           // 11: beerproto.v1.TimingType
	(*MassType)(nil),             // 12: beerproto.v1.MassType
	(*UnitType)(nil),             // 13: beerproto.v1.UnitType
	(*VolumeType)(nil),           // 14: beerproto.v1.VolumeType
}
var file_beerproto_v1_culture_proto_depIdxs = []int32{
	2,  // 0: beerproto.v1.CultureBase.type:type_name -> beerproto.v1.CultureBaseType
	1,  // 1: beerproto.v1.CultureBase.form:type_name -> beerproto.v1.CultureBaseForm
	3,  // 2: beerproto.v1.CultureInformation.base:type_name -> beerproto.v1.CultureBase
	8,  // 3: beerproto.v1.CultureInformation.temperature_range:type_name -> beerproto.v1.TemperatureRangeType
	6,  // 4: beerproto.v1.CultureInformation.inventory:type_name -> beerproto.v1.CultureInventoryType
	9,  // 5: beerproto.v1.CultureInformation.alcohol_tolerance:type_name -> beerproto.v1.PercentType
	2,  // 6: beerproto.v1.CultureInformation.type:type_name -> beerproto.v1.CultureBaseType
	0,  // 7: beerproto.v1.CultureInformation.flocculation:type_name -> beerproto.v1.QualitativeRangeUnit
	10, // 8: beerproto.v1.CultureInformation.attenuation_range:type_name -> beerproto.v1.PercentRangeType
	7,  // 9: beerproto.v1.CultureInformation.zymocide:type_name -> beerproto.v1.Zymocide
	3,  // 10: beerproto.v1.CultureAdditionType.base:type_name -> beerproto.v1.CultureBase
	2,  // 11: beerproto.v1.CultureAdditionType.type:type_name -> beerproto.v1.CultureBaseType
	9,  // 12: beerproto.v1.CultureAdditionType.attenuation:type_name -> beerproto.v1.PercentType
	11, // 13: beerproto.v1.CultureAdditionType.timing:type_name -> beerproto.v1.TimingType
	12, // 14: beerproto.v1.CultureAdditionType.mass:type_name -> beerproto.v1.MassType
	13, // 15: beerproto.v1.CultureAdditionType.unit:type_name -> beerproto.v1.UnitType
	14, // 16: beerproto.v1.CultureAdditionType.volume:type_name -> beerproto.v1.VolumeType
	14, // 17: beerproto.v1.CultureInventoryType.liquid:type_name -> beerproto.v1.VolumeType
	12, // 18: beerproto.v1.CultureInventoryType.dry:type_name -> beerproto.v1.MassType
	14, // 19: beerproto.v1.CultureInventoryType.slant:type_name -> beerproto.v1.VolumeType
	14, // 20: beerproto.v1.CultureInventoryType.culture:type_name -> beerproto.v1.VolumeType
	21, // [21:21] is the sub-list for method output_type
	21, // [21:21] is the sub-list for method input_type
	21, // [21:21] is the sub-list for extension type_name
	21, // [21:21] is the sub-list for extension extendee
	0,  // [0:21] is the sub-list for field type_name
}

func init() { file_beerproto_v1_culture_proto_init() }
func file_beerproto_v1_culture_proto_init() {
	if File_beerproto_v1_culture_proto != nil {
		return
	}
	file_beerproto_v1_measureable_units_proto_init()
	file_beerproto_v1_timing_proto_init()
	file_beerproto_v1_culture_proto_msgTypes[2].OneofWrappers = []any{
		(*CultureAdditionType_Mass)(nil),
		(*CultureAdditionType_Unit)(nil),
		(*CultureAdditionType_Volume)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_beerproto_v1_culture_proto_rawDesc), len(file_beerproto_v1_culture_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_beerproto_v1_culture_proto_goTypes,
		DependencyIndexes: file_beerproto_v1_culture_proto_depIdxs,
		EnumInfos:         file_beerproto_v1_culture_proto_enumTypes,
		MessageInfos:      file_beerproto_v1_culture_proto_msgTypes,
	}.Build()
	File_beerproto_v1_culture_proto = out.File
	file_beerproto_v1_culture_proto_goTypes = nil
	file_beerproto_v1_culture_proto_depIdxs = nil
}
