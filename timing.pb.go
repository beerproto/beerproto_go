//*
// BeerProto
//
// Another beer format, written in protocol buffer.
//
// Copyright (c) 2020 Ross Merrigan

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: beerproto/v1/timing.proto

package beerprotov1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type UseType int32

const (
	UseType_USE_TYPE_UNSPECIFIED UseType = 0
	// add to mash
	UseType_USE_TYPE_ADD_TO_MASH UseType = 1
	// add to boil
	UseType_USE_TYPE_ADD_TO_BOIL UseType = 2
	// add to fermentation
	UseType_USE_TYPE_ADD_TO_FERMENTATION UseType = 3
	// add to package
	UseType_USE_TYPE_ADD_TO_PACKAGE UseType = 4
)

// Enum value maps for UseType.
var (
	UseType_name = map[int32]string{
		0: "USE_TYPE_UNSPECIFIED",
		1: "USE_TYPE_ADD_TO_MASH",
		2: "USE_TYPE_ADD_TO_BOIL",
		3: "USE_TYPE_ADD_TO_FERMENTATION",
		4: "USE_TYPE_ADD_TO_PACKAGE",
	}
	UseType_value = map[string]int32{
		"USE_TYPE_UNSPECIFIED":         0,
		"USE_TYPE_ADD_TO_MASH":         1,
		"USE_TYPE_ADD_TO_BOIL":         2,
		"USE_TYPE_ADD_TO_FERMENTATION": 3,
		"USE_TYPE_ADD_TO_PACKAGE":      4,
	}
)

func (x UseType) Enum() *UseType {
	p := new(UseType)
	*p = x
	return p
}

func (x UseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UseType) Descriptor() protoreflect.EnumDescriptor {
	return file_beerproto_v1_timing_proto_enumTypes[0].Descriptor()
}

func (UseType) Type() protoreflect.EnumType {
	return &file_beerproto_v1_timing_proto_enumTypes[0]
}

func (x UseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UseType.Descriptor instead.
func (UseType) EnumDescriptor() ([]byte, []int) {
	return file_beerproto_v1_timing_proto_rawDescGZIP(), []int{0}
}

// The timing object fully describes the timing of an addition with options for basis on time, gravity, or pH at any process step
type TimingType struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// What time during a process step is added, eg a value of 2 days for a dry hop addition would be added 2 days into the fermentation step.
	Time *TimeType `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	// How long an ingredient addition remains, this was referred to as time in the BeerXML standard. E.G. A 40 minute hop boil additions means to boil for 40 minutes, and a 2 day duration for a dry hop means to remove it after 2 days.
	Duration *TimeType `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty"`
	// A continuous addition is spread out evenly and added during the entire process step, eg 60 minute IPA by dogfish head takes all ofthe hop additions and adds them throughout the entire boil.
	Continuous bool `protobuf:"varint,3,opt,name=continuous,proto3" json:"continuous,omitempty"`
	// Used to indicate when an addition is added based on a desired specific gravity. E.G. Add dry hop at when SG is 1.018.
	SpecificGravity *GravityType `protobuf:"bytes,4,opt,name=specific_gravity,json=specificGravity,proto3" json:"specific_gravity,omitempty"`
	// Used to indicate when an addition is added based on a desired specific pH. eg Add brett when pH is 3.4.
	Ph *AcidityType `protobuf:"bytes,5,opt,name=ph,proto3" json:"ph,omitempty"`
	// Used to indicate what step this ingredient timing addition is referencing. EG A value of 2 for add_to_fermentation would mean to add during the second fermentation step.
	Step          int32   `protobuf:"varint,6,opt,name=step,proto3" json:"step,omitempty"`
	Use           UseType `protobuf:"varint,7,opt,name=use,proto3,enum=beerproto.v1.UseType" json:"use,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TimingType) Reset() {
	*x = TimingType{}
	mi := &file_beerproto_v1_timing_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TimingType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TimingType) ProtoMessage() {}

func (x *TimingType) ProtoReflect() protoreflect.Message {
	mi := &file_beerproto_v1_timing_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TimingType.ProtoReflect.Descriptor instead.
func (*TimingType) Descriptor() ([]byte, []int) {
	return file_beerproto_v1_timing_proto_rawDescGZIP(), []int{0}
}

func (x *TimingType) GetTime() *TimeType {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *TimingType) GetDuration() *TimeType {
	if x != nil {
		return x.Duration
	}
	return nil
}

func (x *TimingType) GetContinuous() bool {
	if x != nil {
		return x.Continuous
	}
	return false
}

func (x *TimingType) GetSpecificGravity() *GravityType {
	if x != nil {
		return x.SpecificGravity
	}
	return nil
}

func (x *TimingType) GetPh() *AcidityType {
	if x != nil {
		return x.Ph
	}
	return nil
}

func (x *TimingType) GetStep() int32 {
	if x != nil {
		return x.Step
	}
	return 0
}

func (x *TimingType) GetUse() UseType {
	if x != nil {
		return x.Use
	}
	return UseType_USE_TYPE_UNSPECIFIED
}

var File_beerproto_v1_timing_proto protoreflect.FileDescriptor

const file_beerproto_v1_timing_proto_rawDesc = "" +
	"\n" +
	"\x19beerproto/v1/timing.proto\x12\fbeerproto.v1\x1a$beerproto/v1/measureable_units.proto\"\xba\x02\n" +
	"\n" +
	"TimingType\x12*\n" +
	"\x04time\x18\x01 \x01(\v2\x16.beerproto.v1.TimeTypeR\x04time\x122\n" +
	"\bduration\x18\x02 \x01(\v2\x16.beerproto.v1.TimeTypeR\bduration\x12\x1e\n" +
	"\n" +
	"continuous\x18\x03 \x01(\bR\n" +
	"continuous\x12D\n" +
	"\x10specific_gravity\x18\x04 \x01(\v2\x19.beerproto.v1.GravityTypeR\x0fspecificGravity\x12)\n" +
	"\x02ph\x18\x05 \x01(\v2\x19.beerproto.v1.AcidityTypeR\x02ph\x12\x12\n" +
	"\x04step\x18\x06 \x01(\x05R\x04step\x12'\n" +
	"\x03use\x18\a \x01(\x0e2\x15.beerproto.v1.UseTypeR\x03use*\x96\x01\n" +
	"\aUseType\x12\x18\n" +
	"\x14USE_TYPE_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14USE_TYPE_ADD_TO_MASH\x10\x01\x12\x18\n" +
	"\x14USE_TYPE_ADD_TO_BOIL\x10\x02\x12 \n" +
	"\x1cUSE_TYPE_ADD_TO_FERMENTATION\x10\x03\x12\x1b\n" +
	"\x17USE_TYPE_ADD_TO_PACKAGE\x10\x04B\xac\x01\n" +
	"\x10com.beerproto.v1B\vTimingProtoP\x01Z:github.com/beerproto/beerproto_go/beerproto/v1;beerprotov1\xa2\x02\x03BXX\xaa\x02\fBeerproto.V1\xca\x02\fBeerproto\\V1\xe2\x02\x18Beerproto\\V1\\GPBMetadata\xea\x02\rBeerproto::V1b\x06proto3"

var (
	file_beerproto_v1_timing_proto_rawDescOnce sync.Once
	file_beerproto_v1_timing_proto_rawDescData []byte
)

func file_beerproto_v1_timing_proto_rawDescGZIP() []byte {
	file_beerproto_v1_timing_proto_rawDescOnce.Do(func() {
		file_beerproto_v1_timing_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_beerproto_v1_timing_proto_rawDesc), len(file_beerproto_v1_timing_proto_rawDesc)))
	})
	return file_beerproto_v1_timing_proto_rawDescData
}

var file_beerproto_v1_timing_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_beerproto_v1_timing_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_beerproto_v1_timing_proto_goTypes = []any{
	(UseType)(0),        // 0: beerproto.v1.UseType
	(*TimingType)(nil),  // 1: beerproto.v1.TimingType
	(*TimeType)(nil),    // 2: beerproto.v1.TimeType
	(*GravityType)(nil), // 3: beerproto.v1.GravityType
	(*AcidityType)(nil), // 4: beerproto.v1.AcidityType
}
var file_beerproto_v1_timing_proto_depIdxs = []int32{
	2, // 0: beerproto.v1.TimingType.time:type_name -> beerproto.v1.TimeType
	2, // 1: beerproto.v1.TimingType.duration:type_name -> beerproto.v1.TimeType
	3, // 2: beerproto.v1.TimingType.specific_gravity:type_name -> beerproto.v1.GravityType
	4, // 3: beerproto.v1.TimingType.ph:type_name -> beerproto.v1.AcidityType
	0, // 4: beerproto.v1.TimingType.use:type_name -> beerproto.v1.UseType
	5, // [5:5] is the sub-list for method output_type
	5, // [5:5] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_beerproto_v1_timing_proto_init() }
func file_beerproto_v1_timing_proto_init() {
	if File_beerproto_v1_timing_proto != nil {
		return
	}
	file_beerproto_v1_measureable_units_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_beerproto_v1_timing_proto_rawDesc), len(file_beerproto_v1_timing_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_beerproto_v1_timing_proto_goTypes,
		DependencyIndexes: file_beerproto_v1_timing_proto_depIdxs,
		EnumInfos:         file_beerproto_v1_timing_proto_enumTypes,
		MessageInfos:      file_beerproto_v1_timing_proto_msgTypes,
	}.Build()
	File_beerproto_v1_timing_proto = out.File
	file_beerproto_v1_timing_proto_goTypes = nil
	file_beerproto_v1_timing_proto_depIdxs = nil
}
